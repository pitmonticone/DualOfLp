import Mathlib

/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

#check LinearMap.continuous_of_finiteDimensional

#check @ContinuousSMul
#synth TopologicalSpace ℝ
variable (n : ℕ)
#synth SMul ℝ (Fin n → ℝ)
#synth AddGroup (Fin n → ℝ)

#check Pi.addGroup
#check Pi.instSMul

variable (n : ℕ)
#synth FiniteDimensional ℝ (Fin n → ℝ)

/-
The usual topology on $\mathbb{R}^{n}$ is the only Hausdorff topology that makes it a topological vector space.
-/
theorem unique_topology_Rn (n : ℕ) (t : TopologicalSpace (Fin n → ℝ))
    (h1 : @T2Space (Fin n → ℝ) t)
    (h2 : @IsTopologicalAddGroup (Fin n → ℝ) t inferInstance)
    (h3 : @ContinuousSMul ℝ (Fin n → ℝ) inferInstance inferInstance t) :
    t = Pi.topologicalSpace := by
  -- Since the identity map is continuous from t to the product topology, t is finer than the product topology.
  have h_finer : t ≤ Pi.topologicalSpace := by
    intro s hs;
    rw [ isOpen_pi_iff ] at hs;
    refine' isOpen_iff_mem_nhds.mpr _;
    intro f hf;
    obtain ⟨ I, u, hu, hsu ⟩ := hs f hf;
    refine' Filter.mem_of_superset _ hsu;
    rw [ mem_nhds_iff ];
    refine' ⟨ { g : Fin n → ℝ | ∀ a ∈ I, g a ∈ u a }, _, _, _ ⟩;
    · exact fun g hg => hg;
    · simp +decide only [Set.setOf_forall];
      refine' isOpen_biInter_finset _;
      -- Since the projection map π_i is continuous, the preimage of an open set under π_i is open.
      have h_proj_cont : ∀ i : Fin n, Continuous (fun x : Fin n → ℝ => x i) := by
        intro i;
        have h_proj_cont : Continuous (fun x : Fin n → ℝ => x i) := by
          have h_linear : ∃ (f : (Fin n → ℝ) →ₗ[ℝ] ℝ), ∀ x : Fin n → ℝ, f x = x i := by
            exact ⟨ LinearMap.proj i, fun x => rfl ⟩
          obtain ⟨ f, hf ⟩ := h_linear;
          convert f.continuous_of_finiteDimensional;
          rw [ hf ];
        exact h_proj_cont;
      exact fun i hi => IsOpen.preimage ( h_proj_cont i ) ( hu i hi |>.1 );
    · aesop;
  apply le_antisymm h_finer;
  apply_rules [ continuous_id_iff_le.mp ];
  convert LinearMap.continuous_of_finiteDimensional _;
  rotate_left;
  exact ℝ;
  all_goals try infer_instance;
  exacts [ LinearMap.id, rfl ]

/-
The only topological vector space over $\mathbb{R}$ with the discrete topology is the zero space
-/
theorem discrete_topology_tvs_zero {V : Type*} [AddCommGroup V] [Module ℝ V]
    [TopologicalSpace V] [DiscreteTopology V] [ContinuousSMul ℝ V] :
    Subsingleton V := by
  exact?

/-
If $V$ is Banach and $v\neq 0$, then some $\varphi \in V^*$ satisfies $\varphi(v) \neq 0$.
-/
theorem banach_exists_mem_dual_eval_ne_zero {V : Type*} [NormedAddCommGroup V] [NormedSpace ℝ V] [CompleteSpace V] (v : V) (hv : v ≠ 0) :
    ∃ φ : V →L[ℝ] ℝ, φ v ≠ 0 := by
  have := exists_dual_vector ℝ v hv;
  exact ⟨ this.choose, this.choose_spec.2.symm ▸ by simpa using hv ⟩

/-
Let $V$ be a Banach space and let $v\neq w$ be two distinct elements of $V$. There is a $\varphi \in V^*$ such that $\varphi(v) \neq \varphi(w)$.
-/
theorem banach_exists_mem_dual_eval_ne {V : Type*} [NormedAddCommGroup V] [NormedSpace ℝ V] [CompleteSpace V] (v w : V) (h : v ≠ w) :
    ∃ φ : V →L[ℝ] ℝ, φ v ≠ φ w := by
  -- Since $v \neq w$, we have $v - w \neq 0$.
  have h_ne : v - w ≠ 0 := by
    exact sub_ne_zero_of_ne h;
  simpa [ sub_ne_zero ] using banach_exists_mem_dual_eval_ne_zero ( v - w ) h_ne

/-
A topological vector space is Bolognese if and only if it is Locally Convex.
-/
def Bolognese (V : Type*) [TopologicalSpace V] [AddCommGroup V] [Module ℝ V] : Prop :=
  ∀ (x : V) (U : Set V), x ∈ U → IsOpen U → ∃ C, IsOpen C ∧ Convex ℝ C ∧ x ∈ C ∧ C ⊆ U

theorem bolognese_iff_lc {V : Type*} [AddCommGroup V] [Module ℝ V] [TopologicalSpace V] [ContinuousSMul ℝ V] [ContinuousAdd V] :
    Bolognese V ↔ LocallyConvexSpace ℝ V := by
  constructor <;> intro h <;> rw [ Bolognese ] at *;
  · -- To prove local convexity, we need to show that every point has a neighborhood base consisting of convex sets.
    have h_local_convex : ∀ x : V, ∀ U : Set V, IsOpen U → x ∈ U → ∃ C : Set V, IsOpen C ∧ Convex ℝ C ∧ x ∈ C ∧ C ⊆ U := by
      exact fun x U hU hx => h x U hx hU;
    refine' { .. } ; aesop;
    refine' ⟨ fun U => ⟨ fun hU => _, fun hU => _ ⟩ ⟩;
    · exact Exists.elim ( h_local_convex x ( interior U ) ( isOpen_interior ) ( mem_interior_iff_mem_nhds.mpr hU ) ) fun C hC => ⟨ C, ⟨ IsOpen.mem_nhds hC.1 ( hC.2.2.1 ), hC.2.1 ⟩, hC.2.2.2.trans interior_subset ⟩;
    · aesop;
      exact Filter.mem_of_superset left right;
  · intro x U hx hU
    obtain ⟨K, hK_convex, hK_neighborhood, hK_subset⟩ : ∃ K : Set V, Convex ℝ K ∧ IsOpen K ∧ x ∈ K ∧ K ⊆ U := by
      have := h.1 x;
      rcases this.mem_iff.mp ( hU.mem_nhds hx ) with ⟨ K, hK₁, hK₂ ⟩ ; use interior K ; aesop;
      · -- Since $K$ is convex, its interior is also convex.
        have h_interior_convex : Convex ℝ (interior K) := by
          have h_convex : Convex ℝ K := right
          exact (by
          convert h_convex.interior using 1
          generalize_proofs at *;
          refine' { continuous_neg := _ };
          have h_neg_cont : Continuous (fun x : V => (-1 : ℝ) • x) := by
            exact continuous_const.smul continuous_id';
          simpa using h_neg_cont);
        exact h_interior_convex;
      · exact mem_interior_iff_mem_nhds.mpr left;
      · exact interior_subset.trans hK₂;
    exact ⟨ K, hK_neighborhood, hK_convex, hK_subset ⟩

/-
Every Banach space is Bolognese.
-/
theorem Bolognese_of_Banach {V : Type*} [NormedAddCommGroup V] [NormedSpace ℝ V] [CompleteSpace V] :
    Bolognese V := by
  -- Since $V$ is a Banach space, it is a normed space, and hence locally convex.
  have h_locally_convex : LocallyConvexSpace ℝ V := by
    infer_instance;
  -- Since $V$ is locally convex, we can apply the lemma `bolognese_iff_lc` to conclude that it is Bolognese.
  apply bolognese_iff_lc.mpr h_locally_convex

#check geometric_hahn_banach_point_closed

/-
Let $V$ be a Bolognese space and let $v\neq w \in V$ be distinct elements of $V$. There is a $\varphi \in V^*$ such that $\varphi(v) \neq \varphi(w)$.
-/
theorem bolognese_exists_mem_dual_eval_ne {V : Type*} [AddCommGroup V] [Module ℝ V] [TopologicalSpace V]
    [ContinuousSMul ℝ V] [ContinuousAdd V] [T2Space V] (hB : Bolognese V) (v w : V) (h : v ≠ w) :
    ∃ φ : V →L[ℝ] ℝ, φ v ≠ φ w := by
  -- Since $V$ is Bolognese, it is locally convex (by `bolognese_iff_lc`).
  have h_loc_conv : LocallyConvexSpace ℝ V := by
    -- By definition of Bolognese, every point has a neighborhood base of convex sets.
    apply bolognese_iff_lc.mp hB;
  have := @geometric_hahn_banach_point_point V;
  contrapose! this;
  refine' ⟨ inferInstance, inferInstance, inferInstance, v, w, _, _, _, _, _ ⟩ <;> aesop;
  · refine' { continuous_add := inst_4.continuous_add, continuous_neg := _ };
    convert continuous_neg;
    -- The negation map is continuous because it is a composition of continuous functions.
    have h_neg_cont : Continuous (fun x : V => (-1 : ℝ) • x) := by
      exact continuous_const.smul continuous_id;
    exact ⟨ by simpa using h_neg_cont ⟩;
  · exact?

open ENNReal

variable (p : ℝ≥0∞)
#check lp (fun _ : ℕ => ℝ) p
#check PreLp (fun _ : ℕ => ℝ)

open MeasureTheory ENNReal

variable {α : Type*} [MeasurableSpace α] {μ : Measure α} {p : ℝ≥0∞}

#check Lp ℝ p μ
#check (eLpNorm (0 : Lp ℝ p μ) p μ).toReal ^ p.toReal

open MeasureTheory

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

#check @Lp.instDist
#check @Lp.instNormedSpace

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

#check MeasureTheory.Lp.instNorm
#check eLpNorm
#check (0 : Lp E p μ)
#check (0 : α →ₘ[μ] E)

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

lemma Lp.dist_triangle_p_lt_one [Fact (0 < p)] [Fact (p < 1)] (f g h : Lp E p μ) :
    (eLpNorm (f - h) p μ).toReal ^ p.toReal ≤ (eLpNorm (f - g) p μ).toReal ^ p.toReal + (eLpNorm (g - h) p μ).toReal ^ p.toReal := by
  -- Apply the inequality $|u + v|^p \leq |u|^p + |v|^p$ for $0 < p < 1$ to the functions $f - g$ and $g - h$.
  have h_ineq : ∀ᵐ x ∂μ, ‖(f - h) x‖ ^ p.toReal ≤ ‖(f - g) x‖ ^ p.toReal + ‖(g - h) x‖ ^ p.toReal := by
    have h_ineq : ∀ x y : E, ‖x + y‖ ^ p.toReal ≤ ‖x‖ ^ p.toReal + ‖y‖ ^ p.toReal := by
      have h_ineq : ∀ x y : ℝ, 0 ≤ x → 0 ≤ y → (x + y) ^ p.toReal ≤ x ^ p.toReal + y ^ p.toReal := by
        intro x y hx hy;
        rcases eq_or_lt_of_le hx with ( rfl | hx ) <;> rcases eq_or_lt_of_le hy with ( rfl | hy ) <;> norm_num;
        · positivity;
        · positivity;
        · positivity;
        · -- By dividing both sides of the inequality by $(x + y)^{p.toReal}$, we get $1 \leq \left(\frac{x}{x + y}\right)^{p.toReal} + \left(\frac{y}{x + y}\right)^{p.toReal}$.
          suffices h_div : 1 ≤ (x / (x + y)) ^ p.toReal + (y / (x + y)) ^ p.toReal by
            rw [ Real.div_rpow ( by positivity ) ( by positivity ), Real.div_rpow ( by positivity ) ( by positivity ) ] at h_div;
            rwa [ ← add_div, one_le_div ( by positivity ) ] at h_div;
          exact le_trans ( by norm_num [ ← add_div, div_self ( ne_of_gt ( add_pos hx hy ) ) ] ) ( add_le_add ( Real.rpow_le_rpow_of_exponent_ge ( by positivity ) ( div_le_one_of_le₀ ( by linarith ) ( by positivity ) ) ( show p.toReal ≤ 1 from by simpa using ENNReal.toReal_mono ( by aesop ) ( show p ≤ 1 from le_of_lt ( Fact.out ) ) ) ) ( Real.rpow_le_rpow_of_exponent_ge ( by positivity ) ( div_le_one_of_le₀ ( by linarith ) ( by positivity ) ) ( show p.toReal ≤ 1 from by simpa using ENNReal.toReal_mono ( by aesop ) ( show p ≤ 1 from le_of_lt ( Fact.out ) ) ) ) );
      exact fun x y => le_trans ( Real.rpow_le_rpow ( norm_nonneg _ ) ( norm_add_le _ _ ) ( ENNReal.toReal_nonneg ) ) ( h_ineq _ _ ( norm_nonneg _ ) ( norm_nonneg _ ) );
    have h_ineq : ∀ᵐ x ∂μ, ‖(f - h) x‖ ^ p.toReal = ‖(f - g) x + (g - h) x‖ ^ p.toReal := by
      filter_upwards [ MeasureTheory.Lp.coeFn_sub f h, MeasureTheory.Lp.coeFn_sub f g, MeasureTheory.Lp.coeFn_sub g h ] with x hx₁ hx₂ hx₃ ; simp_all +decide [ sub_add_sub_cancel ];
    filter_upwards [ h_ineq ] with x hx using hx.symm ▸ by solve_by_elim;
  -- Apply the inequality $|u + v|^p \leq |u|^p + |v|^p$ to the functions $(f - g)$ and $(g - h)$.
  have h_ineq : ∫ x, ‖(f - h) x‖ ^ p.toReal ∂μ ≤ ∫ x, ‖(f - g) x‖ ^ p.toReal ∂μ + ∫ x, ‖(g - h) x‖ ^ p.toReal ∂μ := by
    rw [ ← MeasureTheory.integral_add ];
    · refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
      · exact Filter.Eventually.of_forall fun x => Real.rpow_nonneg ( norm_nonneg _ ) _;
      · refine' MeasureTheory.Integrable.add _ _;
        · have := MeasureTheory.Lp.memLp ( f - g );
          have := this.norm_rpow;
          by_cases hp : p = 0 <;> by_cases hp' : p = ⊤ <;> simp_all +decide [ MeasureTheory.memLp_one_iff_integrable ];
        · have := MeasureTheory.Lp.memLp ( g - h );
          have := this.integrable_norm_rpow;
          exact this ( ne_of_gt ( Fact.out : 0 < p ) ) ( ne_of_lt ( lt_of_lt_of_le ( Fact.out : p < 1 ) ( by norm_num ) ) );
      · exact h_ineq;
    · have := MeasureTheory.Lp.memLp ( f - g );
      convert this.integrable_norm_rpow _;
      · aesop;
        exact Or.inl ( ne_of_lt ( lt_of_lt_of_le ( Fact.out : p < 1 ) ( by norm_num ) ) );
      · exact ne_of_gt Fact.out;
    · have h_integrable : MeasureTheory.MemLp (fun x => ‖(g - h) x‖) p μ := by
        exact MeasureTheory.MemLp.norm ( MeasureTheory.Lp.memLp _ );
      convert h_integrable.integrable_norm_rpow _;
      · cases p <;> aesop;
        exact False.elim <| Fact.out;
      · exact ne_of_gt Fact.out;
  -- Apply the fact that the integral of |u|^p is equal to the eLpNorm of u raised to the power p.toReal.
  have h_integral_eLpNorm : ∀ u : ↥(MeasureTheory.Lp E p μ), ∫ x, ‖u x‖ ^ p.toReal ∂μ = (MeasureTheory.eLpNorm u p μ).toReal ^ p.toReal := by
    intro u; rw [ MeasureTheory.eLpNorm_eq_lintegral_rpow_enorm ] ; aesop;
    · rw [ ← ENNReal.toReal_rpow ];
      by_cases hp : p.toReal = 0 <;> aesop;
      · rw [ ENNReal.toReal_eq_zero_iff ] at hp ; aesop;
        · exact False.elim <| Fact.out;
        · exact False.elim <| Fact.out;
      · rw [ MeasureTheory.integral_eq_lintegral_of_nonneg_ae ];
        · simp +decide [ ← ENNReal.ofReal_rpow_of_nonneg ( norm_nonneg _ ) ( by positivity : 0 ≤ p.toReal ), Real.enorm_eq_ofReal ( norm_nonneg _ ) ];
        · exact Filter.Eventually.of_forall fun x => Real.rpow_nonneg ( norm_nonneg _ ) _;
        · exact ( val_3.aestronglyMeasurable.norm.aemeasurable.pow_const _ ).aestronglyMeasurable;
    · exact ne_of_gt Fact.out;
    · exact ne_of_lt ( lt_of_lt_of_le ( Fact.out : p < 1 ) ( by norm_num ) );
  aesop;
  rw [ ← h_integral_eLpNorm, ← h_integral_eLpNorm, ← h_integral_eLpNorm ];
  · exact h_ineq;
  · exact?;
  · exact?;
  · exact?

/-
Definition of the distance function for $L^p$ with $0 < p < 1$.
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

noncomputable def Lp.dist_p_lt_one (p : ℝ≥0∞) (f g : Lp E p μ) : ℝ :=
  (eLpNorm (f - g) p μ).toReal ^ p.toReal

/-
Let $(X,\mu)$ be a measure space. For every $0<p$ the space $L^p(\mu)$ is a metric space with metric
\[
d(f, g)= \begin{cases}
    \left(\int_{X}|f-g|^{p} \mathrm{~d} \mu\right)^{1 / p}, & \text { if } p \geq 1 \\ \int_{X}|f-g|^{p} \mathrm{~d} \mu, & \text { if } 0<p<1
    \end{cases}
\]
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

/-- Theorem 3.12: For every 0 < p < 1, the space L^p(μ) is a metric space. -/
noncomputable def Lp.metricSpace_p_lt_one [Fact (0 < p)] [Fact (p < 1)] :
    MetricSpace (Lp E p μ) where
  dist := Lp.dist_p_lt_one p
  dist_self := by
    -- The distance from x to x is zero because the Lp norm of the zero function is zero.
    simp [Lp.dist_p_lt_one];
    rw [ MeasureTheory.eLpNorm_congr_ae ( MeasureTheory.AEEqFun.coeFn_zero ) ];
    rw [ MeasureTheory.eLpNorm_zero ] ; aesop;
    rw [ Real.zero_rpow ];
    aesop;
    rw [ ENNReal.toReal_eq_zero_iff ] at a ; aesop;
    · exact Fact.out;
    · exact False.elim <| Fact.out
  dist_comm := by
    simp +zetaDelta at *;
    -- Since $|f - g| = |g - f|$, the integrals are equal, hence the distances are equal.
    intros a ha b hb
    simp [Lp.dist_p_lt_one, abs_sub_comm];
    rw [ MeasureTheory.eLpNorm_congr_ae ( MeasureTheory.AEEqFun.coeFn_sub .. ), MeasureTheory.eLpNorm_congr_ae ( MeasureTheory.AEEqFun.coeFn_sub .. ) ];
    rw [ ← neg_sub, MeasureTheory.eLpNorm_neg ]
  dist_triangle := by
    -- Apply the triangle inequality for the norm in L^p space with p < 1.
    apply Lp.dist_triangle_p_lt_one
    skip
  eq_of_dist_eq_zero := by
    -- If the distance between two elements x and y in Lp is zero, then their difference must be zero almost everywhere.
    have h_zero_ae : ∀ {x y : MeasureTheory.Lp E p μ}, (eLpNorm (x - y) p μ).toReal = 0 → x = y := by
      intro x y hxy;
      rw [ ENNReal.toReal_eq_zero_iff ] at hxy;
      cases' hxy with hxy hxy;
      · rw [ MeasureTheory.eLpNorm_eq_zero_iff ] at hxy;
        · -- Since $x - y = 0$ almost everywhere, we have $x = y$ in the $L^p$ space.
          have h_eq : (x - y : MeasureTheory.Lp E p μ) = 0 := by
            exact?;
          exact eq_of_sub_eq_zero h_eq;
        · exact MeasureTheory.AEStronglyMeasurable.mono_measure ( MeasureTheory.Lp.aestronglyMeasurable _ ) le_rfl;
        · exact ne_of_gt Fact.out;
      · exact False.elim ( hxy.not_lt <| MeasureTheory.Lp.eLpNorm_lt_top _ );
    intro x y hxy
    apply h_zero_ae;
    unfold Lp.dist_p_lt_one at hxy;
    rw [ Real.rpow_eq_zero_iff_of_nonneg ] at hxy <;> aesop

/-
Let $(X,\mu)$ be a measure space. For every $0<p$ the space $L^p(\mu)$ is a metric space with metric
\[
d(f, g)= \begin{cases}
    \left(\int_{X}|f-g|^{p} \mathrm{~d} \mu\right)^{1 / p}, & \text { if } p \geq 1 \\ \int_{X}|f-g|^{p} \mathrm{~d} \mu, & \text { if } 0<p<1
    \end{cases}
\]
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

/-- Theorem 3.12: For every 0 < p < 1, the space L^p(μ) is a metric space. -/
noncomputable instance Lp.instMetricSpace_p_lt_one [Fact (0 < p)] [Fact (p < 1)] :
    MetricSpace (Lp E p μ) where
  dist := Lp.dist_p_lt_one p
  dist_self := by
    bound;
    -- The eLpNorm of the zero function is zero because the integral of the p-th power of the zero function over any measure space is zero.
    have h_zero : eLpNorm (val - val) p μ = 0 := by
      -- The eLpNorm of the zero function is zero because the integral of the p-th power of the zero function over any measure space is zero. We can use the fact that the integral of the zero function is zero.
      have h_zero : eLpNorm (fun _ => 0 : α → E) p μ = 0 := by
        bound;
      convert h_zero using 1;
      exact MeasureTheory.eLpNorm_congr_ae ( by filter_upwards [ val.coeFn_sub val ] with x hx; aesop );
    unfold Lp.dist_p_lt_one;
    norm_num +zetaDelta at *;
    rw [ h_zero, ENNReal.toReal_zero, Real.zero_rpow ] ; exact ne_of_gt ( ENNReal.toReal_pos ( ne_of_gt ( Fact.out : 0 < p ) ) ( ne_of_lt ( lt_of_lt_of_le ( Fact.out : p < 1 ) ( by norm_num ) ) ) )
  dist_comm := by
    norm_num +zetaDelta at *;
    -- The eLpNorm is symmetric, so eLpNorm (a - b) p μ = eLpNorm (b - a) p μ.
    have h_symm : ∀ (a b : α →ₘ[μ] E), eLpNorm (a - b) p μ = eLpNorm (b - a) p μ := by
      -- Since $|a - b| = |b - a|$, we have $|a - b|^p = |b - a|^p$.
      have h_abs : ∀ (a b : α →ₘ[μ] E), ∀ᵐ x ∂μ, ‖(a - b) x‖ = ‖(b - a) x‖ := by
        aesop;
        filter_upwards [ a.coeFn_sub b, b.coeFn_sub a ] with x hx₁ hx₂ using by simp +decide [ hx₁, hx₂, norm_sub_rev ] ;
      exact?;
    -- Since the eLpNorm is symmetric, raising both sides to the same power preserves the equality.
    intros a ha b hb
    simp [Lp.dist_p_lt_one, h_symm]
  dist_triangle := by
    -- By definition of $L^p$ spaces, we know that the distance function $d(f, g) = \|f - g\|_p^p$ satisfies the triangle inequality.
    intros x y z
    apply Lp.dist_triangle_p_lt_one
  eq_of_dist_eq_zero := by
    bound;
    -- If the distance is zero, then the Lp norm of their difference must be zero.
    have h_norm_zero : eLpNorm (val - val_1) p μ = 0 := by
      contrapose! a;
      refine' ne_of_gt ( Real.rpow_pos_of_pos _ _ );
      exact ENNReal.toReal_pos a ( ne_of_lt ( MeasureTheory.Lp.memLp _ |> fun h => h.2 ) );
    rw [ MeasureTheory.eLpNorm_eq_zero_iff ] at h_norm_zero;
    · -- Since val - val_1 is almost everywhere zero, val and val_1 are equal almost everywhere.
      have h_eq_ae : val =ᵐ[μ] val_1 := by
        -- Since the difference of two functions is zero almost everywhere, the functions themselves are almost everywhere equal.
        have h_eq_ae : (val - val_1) =ᵐ[μ] 0 → val =ᵐ[μ] val_1 := by
          -- If the difference of two functions is zero almost everywhere, then the functions themselves are almost everywhere equal. This follows directly from the definition of almost everywhere equality.
          intros h_diff_zero
          have h_eq_ae : ∀ᵐ x ∂μ, val x = val_1 x := by
            filter_upwards [ h_diff_zero, val.coeFn_sub val_1 ] with x hx₁ hx₂ using by simpa [ sub_eq_zero ] using hx₂.symm.trans hx₁;
          exact h_eq_ae;
        exact h_eq_ae h_norm_zero;
      exact Subtype.eq ( MeasureTheory.AEEqFun.ext h_eq_ae );
    · exact?;
    · exact ne_of_gt inst_13.1

/-
$d(f, f) = 0$ for the $L^p$ metric with $0 < p < 1$.
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

lemma Lp.dist_p_lt_one_self [Fact (0 < p)] [Fact (p < 1)] (f : Lp E p μ) :
    Lp.dist_p_lt_one p f f = 0 := by
      simp +decide [ Lp.dist_p_lt_one ];
      rw [ MeasureTheory.eLpNorm_congr_ae ( MeasureTheory.AEEqFun.coeFn_zero ) ] ; aesop;
      rw [ Real.zero_rpow ];
      aesop;
      rw [ ENNReal.toReal_eq_zero_iff ] at a ; aesop;
      · exact Fact.out;
      · exact False.elim <| Fact.out

/-
Symmetry of the $L^p$ distance for $0 < p < 1$.
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

lemma Lp.dist_p_lt_one_comm (p : ℝ≥0∞) (f g : Lp E p μ) :
    Lp.dist_p_lt_one p f g = Lp.dist_p_lt_one p g f := by
      unfold Lp.dist_p_lt_one;
      bound;
      -- Since the integral of an absolute value is symmetric, we have:
      have h_symm : ∀ f : α →ₘ[μ] E, (MeasureTheory.eLpNorm (↑(↑f) : α → E) p μ).toReal = (MeasureTheory.eLpNorm (↑(↑(-f)) : α → E) p μ).toReal := by
        intro f; rw [ MeasureTheory.eLpNorm_congr_ae ( MeasureTheory.AEEqFun.coeFn_neg _ ) ] ; simp +decide ;
      convert congr_arg ( fun x => x ^ p.toReal ) ( h_symm ( val - val_1 ) ) using 2 ; norm_num

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

lemma Lp.dist_triangle_p_lt_one' [Fact (0 < p)] [Fact (p < 1)] (f g h : Lp E p μ) :
    (eLpNorm (f - h) p μ).toReal ^ p.toReal ≤ (eLpNorm (f - g) p μ).toReal ^ p.toReal + (eLpNorm (g - h) p μ).toReal ^ p.toReal := by
      exact?

/-
$d(f, g) = 0 \implies f = g$ for the $L^p$ metric with $0 < p < 1$.
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

lemma Lp.eq_of_dist_p_lt_one_eq_zero [Fact (0 < p)] [Fact (p < 1)] (f g : Lp E p μ) (h : Lp.dist_p_lt_one p f g = 0) : f = g := by
  refine' eq_of_dist_eq_zero _;
  convert h

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

#check Lp.dist_p_lt_one
#check Lp.dist_triangle_p_lt_one
#check Lp.metricSpace_p_lt_one
#check Lp.instMetricSpace_p_lt_one

/-
Triangle inequality for $L^p$ metric with $0 < p < 1$.
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

lemma Lp.dist_triangle_p_lt_one_proof [Fact (0 < p)] [Fact (p < 1)] (f g h : Lp E p μ) :
    (eLpNorm (f - h) p μ).toReal ^ p.toReal ≤ (eLpNorm (f - g) p μ).toReal ^ p.toReal + (eLpNorm (g - h) p μ).toReal ^ p.toReal := by
      exact?

/-
For every $1\le p$ the space $L^p(\mu)$ is Bolognese.
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] [NormedSpace ℝ E] {μ : Measure α} {p : ℝ≥0∞}

theorem Lp_bolognese_of_p_ge_1 [Fact (1 ≤ p)] : Bolognese (Lp E p μ) := by
  intro x U hx hU;
  -- Since $U$ is open, there exists $\epsilon > 0$ such that the ball $B(x, \epsilon) \subseteq U$.
  obtain ⟨ε, hε_pos, hε⟩ : ∃ ε > 0, Metric.ball x ε ⊆ U := by
    exact Metric.isOpen_iff.1 hU x hx;
  refine' ⟨ Metric.ball x ε, Metric.isOpen_ball, convex_ball _ _, Metric.mem_ball_self hε_pos, hε ⟩

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] [NormedSpace ℝ E] {μ : Measure α} {p : ℝ≥0∞}

#synth Module ℝ (Lp E p μ)

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] [NormedSpace ℝ E] {μ : Measure α} {p : ℝ≥0∞}

#synth Module ℝ (Lp E p μ)

#print MeasureTheory.Lp.instModule

open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] [NormedSpace ℝ E] {μ : Measure α} {p : ℝ≥0∞}

#check Lp.dist_triangle_p_lt_one
#synth Module ℝ (Lp E p μ)
#synth IsBoundedSMul ℝ E

/-
Let $(X,\mu)$ be a measure space. For every $0<p$ the space $L^p(\mu)$ is a metric space with metric
\[
d(f, g)= \begin{cases}
    \left(\int_{X}|f-g|^{p} \mathrm{~d} \mu\right)^{1 / p}, & \text { if } p \geq 1 \\ \int_{X}|f-g|^{p} \mathrm{~d} \mu, & \text { if } 0<p<1
    \end{cases}
\]
-/
open MeasureTheory ENNReal

variable {α E : Type*} [MeasurableSpace α] [NormedAddCommGroup E] {μ : Measure α} {p : ℝ≥0∞}

/-- Theorem 3.12: For every 0 < p, the space L^p(μ) is a metric space. -/
noncomputable def Lp_mu_metric (p : ℝ≥0∞) [Fact (0 < p)] : MetricSpace (Lp E p μ) := by
  by_cases hp : 1 ≤ p
  · have : Fact (1 ≤ p) := ⟨hp⟩
    infer_instance
  · have : Fact (p < 1) := ⟨lt_of_not_ge hp⟩
    exact Lp.metricSpace_p_lt_one
